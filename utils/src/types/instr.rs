// auto-generated, do not edit
use super::*;
use crate::buffer::{Buffer, Writable};
use crate::decode::*;
use crate::types::method_selector::MethodSelector;
#[cfg_attr(test, derive(Debug, PartialEq))]
pub enum Instr {
    CallLocal(Byte),
    CallExternal(Byte),
    Return,
    ConstTrue,
    ConstFalse,
    I256Const0,
    I256Const1,
    I256Const2,
    I256Const3,
    I256Const4,
    I256Const5,
    I256ConstN1,
    U256Const0,
    U256Const1,
    U256Const2,
    U256Const3,
    U256Const4,
    U256Const5,
    I256Const(I256),
    U256Const(U256),
    BytesConst(ByteString),
    AddressConst(LockupScript),
    LoadLocal(Byte),
    StoreLocal(Byte),
    Pop,
    BoolNot,
    BoolAnd,
    BoolOr,
    BoolEq,
    BoolNeq,
    BoolToByteVec,
    I256Add,
    I256Sub,
    I256Mul,
    I256Div,
    I256Mod,
    I256Eq,
    I256Neq,
    I256Lt,
    I256Le,
    I256Gt,
    I256Ge,
    U256Add,
    U256Sub,
    U256Mul,
    U256Div,
    U256Mod,
    U256Eq,
    U256Neq,
    U256Lt,
    U256Le,
    U256Gt,
    U256Ge,
    U256ModAdd,
    U256ModSub,
    U256ModMul,
    U256BitAnd,
    U256BitOr,
    U256Xor,
    U256SHL,
    U256SHR,
    I256ToU256,
    I256ToByteVec,
    U256ToI256,
    U256ToByteVec,
    ByteVecEq,
    ByteVecNeq,
    ByteVecSize,
    ByteVecConcat,
    AddressEq,
    AddressNeq,
    AddressToByteVec,
    IsAssetAddress,
    IsContractAddress,
    Jump(I32),
    IfTrue(I32),
    IfFalse(I32),
    Assert,
    Blake2b,
    Keccak256,
    Sha256,
    Sha3,
    VerifyTxSignature,
    VerifySecP256K1,
    VerifyED25519,
    NetworkId,
    BlockTimeStamp,
    BlockTarget,
    TxId,
    TxInputAddressAt,
    TxInputsSize,
    VerifyAbsoluteLocktime,
    VerifyRelativeLocktime,
    Log1,
    Log2,
    Log3,
    Log4,
    Log5,
    ByteVecSlice,
    ByteVecToAddress,
    Encode,
    Zeros,
    U256To1Byte,
    U256To2Byte,
    U256To4Byte,
    U256To8Byte,
    U256To16Byte,
    U256To32Byte,
    U256From1Byte,
    U256From2Byte,
    U256From4Byte,
    U256From8Byte,
    U256From16Byte,
    U256From32Byte,
    EthEcRecover,
    Log6,
    Log7,
    Log8,
    Log9,
    ContractIdToAddress,
    LoadLocalByIndex,
    StoreLocalByIndex,
    Dup,
    AssertWithErrorCode,
    Swap,
    BlockHash,
    DEBUG(AVector<ByteString>),
    TxGasPrice,
    TxGasAmount,
    TxGasFee,
    I256Exp,
    U256Exp,
    U256ModExp,
    VerifyBIP340Schnorr,
    GetSegregatedSignature,
    MulModN,
    AddModN,
    U256ToString,
    I256ToString,
    BoolToString,
    GroupOfAddress,
    LoadMutField(Byte),
    StoreMutField(Byte),
    ApproveAlph,
    ApproveToken,
    AlphRemaining,
    TokenRemaining,
    IsPaying,
    TransferAlph,
    TransferAlphFromSelf,
    TransferAlphToSelf,
    TransferToken,
    TransferTokenFromSelf,
    TransferTokenToSelf,
    CreateContract,
    CreateContractWithToken,
    CopyCreateContract,
    DestroySelf,
    SelfContractId,
    SelfAddress,
    CallerContractId,
    CallerAddress,
    IsCalledFromTxScript,
    CallerInitialStateHash,
    CallerCodeHash,
    ContractInitialStateHash,
    ContractCodeHash,
    MigrateSimple,
    MigrateWithFields,
    CopyCreateContractWithToken,
    BurnToken,
    LockApprovedAssets,
    CreateSubContract,
    CreateSubContractWithToken,
    CopyCreateSubContract,
    CopyCreateSubContractWithToken,
    LoadMutFieldByIndex,
    StoreMutFieldByIndex,
    ContractExists,
    CreateContractAndTransferToken,
    CopyCreateContractAndTransferToken,
    CreateSubContractAndTransferToken,
    CopyCreateSubContractAndTransferToken,
    NullContractAddress,
    SubContractId,
    SubContractIdOf,
    ALPHTokenId,
    LoadImmField(Byte),
    LoadImmFieldByIndex,
    PayGasFee,
    MinimalContractDeposit,
    CreateMapEntry(Byte, Byte),
    MethodSelector(MethodSelector),
    CallExternalBySelector(MethodSelector),
    Unknown,
}
impl Reset for Instr {
    fn reset(&mut self) {
        *self = Self::Unknown;
    }
}
impl Default for Instr {
    fn default() -> Self {
        Self::Unknown
    }
}
impl Instr {
    fn from_type(tpe: u8) -> Option<Self> {
        match tpe {
            0 => Some(Self::CallLocal(Byte::default())),
            1 => Some(Self::CallExternal(Byte::default())),
            2 => Some(Self::Return),
            3 => Some(Self::ConstTrue),
            4 => Some(Self::ConstFalse),
            5 => Some(Self::I256Const0),
            6 => Some(Self::I256Const1),
            7 => Some(Self::I256Const2),
            8 => Some(Self::I256Const3),
            9 => Some(Self::I256Const4),
            10 => Some(Self::I256Const5),
            11 => Some(Self::I256ConstN1),
            12 => Some(Self::U256Const0),
            13 => Some(Self::U256Const1),
            14 => Some(Self::U256Const2),
            15 => Some(Self::U256Const3),
            16 => Some(Self::U256Const4),
            17 => Some(Self::U256Const5),
            18 => Some(Self::I256Const(I256::default())),
            19 => Some(Self::U256Const(U256::default())),
            20 => Some(Self::BytesConst(ByteString::default())),
            21 => Some(Self::AddressConst(LockupScript::default())),
            22 => Some(Self::LoadLocal(Byte::default())),
            23 => Some(Self::StoreLocal(Byte::default())),
            24 => Some(Self::Pop),
            25 => Some(Self::BoolNot),
            26 => Some(Self::BoolAnd),
            27 => Some(Self::BoolOr),
            28 => Some(Self::BoolEq),
            29 => Some(Self::BoolNeq),
            30 => Some(Self::BoolToByteVec),
            31 => Some(Self::I256Add),
            32 => Some(Self::I256Sub),
            33 => Some(Self::I256Mul),
            34 => Some(Self::I256Div),
            35 => Some(Self::I256Mod),
            36 => Some(Self::I256Eq),
            37 => Some(Self::I256Neq),
            38 => Some(Self::I256Lt),
            39 => Some(Self::I256Le),
            40 => Some(Self::I256Gt),
            41 => Some(Self::I256Ge),
            42 => Some(Self::U256Add),
            43 => Some(Self::U256Sub),
            44 => Some(Self::U256Mul),
            45 => Some(Self::U256Div),
            46 => Some(Self::U256Mod),
            47 => Some(Self::U256Eq),
            48 => Some(Self::U256Neq),
            49 => Some(Self::U256Lt),
            50 => Some(Self::U256Le),
            51 => Some(Self::U256Gt),
            52 => Some(Self::U256Ge),
            53 => Some(Self::U256ModAdd),
            54 => Some(Self::U256ModSub),
            55 => Some(Self::U256ModMul),
            56 => Some(Self::U256BitAnd),
            57 => Some(Self::U256BitOr),
            58 => Some(Self::U256Xor),
            59 => Some(Self::U256SHL),
            60 => Some(Self::U256SHR),
            61 => Some(Self::I256ToU256),
            62 => Some(Self::I256ToByteVec),
            63 => Some(Self::U256ToI256),
            64 => Some(Self::U256ToByteVec),
            65 => Some(Self::ByteVecEq),
            66 => Some(Self::ByteVecNeq),
            67 => Some(Self::ByteVecSize),
            68 => Some(Self::ByteVecConcat),
            69 => Some(Self::AddressEq),
            70 => Some(Self::AddressNeq),
            71 => Some(Self::AddressToByteVec),
            72 => Some(Self::IsAssetAddress),
            73 => Some(Self::IsContractAddress),
            74 => Some(Self::Jump(I32::default())),
            75 => Some(Self::IfTrue(I32::default())),
            76 => Some(Self::IfFalse(I32::default())),
            77 => Some(Self::Assert),
            78 => Some(Self::Blake2b),
            79 => Some(Self::Keccak256),
            80 => Some(Self::Sha256),
            81 => Some(Self::Sha3),
            82 => Some(Self::VerifyTxSignature),
            83 => Some(Self::VerifySecP256K1),
            84 => Some(Self::VerifyED25519),
            85 => Some(Self::NetworkId),
            86 => Some(Self::BlockTimeStamp),
            87 => Some(Self::BlockTarget),
            88 => Some(Self::TxId),
            89 => Some(Self::TxInputAddressAt),
            90 => Some(Self::TxInputsSize),
            91 => Some(Self::VerifyAbsoluteLocktime),
            92 => Some(Self::VerifyRelativeLocktime),
            93 => Some(Self::Log1),
            94 => Some(Self::Log2),
            95 => Some(Self::Log3),
            96 => Some(Self::Log4),
            97 => Some(Self::Log5),
            98 => Some(Self::ByteVecSlice),
            99 => Some(Self::ByteVecToAddress),
            100 => Some(Self::Encode),
            101 => Some(Self::Zeros),
            102 => Some(Self::U256To1Byte),
            103 => Some(Self::U256To2Byte),
            104 => Some(Self::U256To4Byte),
            105 => Some(Self::U256To8Byte),
            106 => Some(Self::U256To16Byte),
            107 => Some(Self::U256To32Byte),
            108 => Some(Self::U256From1Byte),
            109 => Some(Self::U256From2Byte),
            110 => Some(Self::U256From4Byte),
            111 => Some(Self::U256From8Byte),
            112 => Some(Self::U256From16Byte),
            113 => Some(Self::U256From32Byte),
            114 => Some(Self::EthEcRecover),
            115 => Some(Self::Log6),
            116 => Some(Self::Log7),
            117 => Some(Self::Log8),
            118 => Some(Self::Log9),
            119 => Some(Self::ContractIdToAddress),
            120 => Some(Self::LoadLocalByIndex),
            121 => Some(Self::StoreLocalByIndex),
            122 => Some(Self::Dup),
            123 => Some(Self::AssertWithErrorCode),
            124 => Some(Self::Swap),
            125 => Some(Self::BlockHash),
            126 => Some(Self::DEBUG(AVector::default())),
            127 => Some(Self::TxGasPrice),
            128 => Some(Self::TxGasAmount),
            129 => Some(Self::TxGasFee),
            130 => Some(Self::I256Exp),
            131 => Some(Self::U256Exp),
            132 => Some(Self::U256ModExp),
            133 => Some(Self::VerifyBIP340Schnorr),
            134 => Some(Self::GetSegregatedSignature),
            135 => Some(Self::MulModN),
            136 => Some(Self::AddModN),
            137 => Some(Self::U256ToString),
            138 => Some(Self::I256ToString),
            139 => Some(Self::BoolToString),
            140 => Some(Self::GroupOfAddress),
            160 => Some(Self::LoadMutField(Byte::default())),
            161 => Some(Self::StoreMutField(Byte::default())),
            162 => Some(Self::ApproveAlph),
            163 => Some(Self::ApproveToken),
            164 => Some(Self::AlphRemaining),
            165 => Some(Self::TokenRemaining),
            166 => Some(Self::IsPaying),
            167 => Some(Self::TransferAlph),
            168 => Some(Self::TransferAlphFromSelf),
            169 => Some(Self::TransferAlphToSelf),
            170 => Some(Self::TransferToken),
            171 => Some(Self::TransferTokenFromSelf),
            172 => Some(Self::TransferTokenToSelf),
            173 => Some(Self::CreateContract),
            174 => Some(Self::CreateContractWithToken),
            175 => Some(Self::CopyCreateContract),
            176 => Some(Self::DestroySelf),
            177 => Some(Self::SelfContractId),
            178 => Some(Self::SelfAddress),
            179 => Some(Self::CallerContractId),
            180 => Some(Self::CallerAddress),
            181 => Some(Self::IsCalledFromTxScript),
            182 => Some(Self::CallerInitialStateHash),
            183 => Some(Self::CallerCodeHash),
            184 => Some(Self::ContractInitialStateHash),
            185 => Some(Self::ContractCodeHash),
            186 => Some(Self::MigrateSimple),
            187 => Some(Self::MigrateWithFields),
            188 => Some(Self::CopyCreateContractWithToken),
            189 => Some(Self::BurnToken),
            190 => Some(Self::LockApprovedAssets),
            191 => Some(Self::CreateSubContract),
            192 => Some(Self::CreateSubContractWithToken),
            193 => Some(Self::CopyCreateSubContract),
            194 => Some(Self::CopyCreateSubContractWithToken),
            195 => Some(Self::LoadMutFieldByIndex),
            196 => Some(Self::StoreMutFieldByIndex),
            197 => Some(Self::ContractExists),
            198 => Some(Self::CreateContractAndTransferToken),
            199 => Some(Self::CopyCreateContractAndTransferToken),
            200 => Some(Self::CreateSubContractAndTransferToken),
            201 => Some(Self::CopyCreateSubContractAndTransferToken),
            202 => Some(Self::NullContractAddress),
            203 => Some(Self::SubContractId),
            204 => Some(Self::SubContractIdOf),
            205 => Some(Self::ALPHTokenId),
            206 => Some(Self::LoadImmField(Byte::default())),
            207 => Some(Self::LoadImmFieldByIndex),
            208 => Some(Self::PayGasFee),
            209 => Some(Self::MinimalContractDeposit),
            210 => Some(Self::CreateMapEntry(Byte::default(), Byte::default())),
            211 => Some(Self::MethodSelector(MethodSelector::default())),
            212 => Some(Self::CallExternalBySelector(MethodSelector::default())),
            _ => None,
        }
    }
}
impl RawDecoder for Instr {
    fn step_size(&self) -> u16 {
        match self {
            Self::CallLocal(v0) => v0.step_size(),
            Self::CallExternal(v0) => v0.step_size(),
            Self::I256Const(v0) => v0.step_size(),
            Self::U256Const(v0) => v0.step_size(),
            Self::BytesConst(v0) => v0.step_size(),
            Self::AddressConst(v0) => v0.step_size(),
            Self::LoadLocal(v0) => v0.step_size(),
            Self::StoreLocal(v0) => v0.step_size(),
            Self::Jump(v0) => v0.step_size(),
            Self::IfTrue(v0) => v0.step_size(),
            Self::IfFalse(v0) => v0.step_size(),
            Self::DEBUG(v0) => v0.step_size(),
            Self::LoadMutField(v0) => v0.step_size(),
            Self::StoreMutField(v0) => v0.step_size(),
            Self::LoadImmField(v0) => v0.step_size(),
            Self::CreateMapEntry(v0, v1) => v0.step_size() + v1.step_size(),
            Self::MethodSelector(v0) => v0.step_size(),
            Self::CallExternalBySelector(v0) => v0.step_size(),
            _ => 1,
        }
    }
    fn decode<'a, W: Writable>(
        &mut self,
        buffer: &mut Buffer<'a, W>,
        stage: &DecodeStage,
    ) -> DecodeResult<DecodeStage> {
        if buffer.is_empty() {
            return Ok(DecodeStage { ..*stage });
        }
        match self {
            Self::Unknown => {
                let tpe = buffer.consume_byte().unwrap();
                let result = Self::from_type(tpe);
                if result.is_none() {
                    *self = Instr::Unknown;
                } else {
                    *self = result.unwrap();
                }
            }
            _ => (),
        };
        match self {
            Self::CallLocal(v0) => v0.decode(buffer, stage),
            Self::CallExternal(v0) => v0.decode(buffer, stage),
            Self::I256Const(v0) => v0.decode(buffer, stage),
            Self::U256Const(v0) => v0.decode(buffer, stage),
            Self::BytesConst(v0) => v0.decode(buffer, stage),
            Self::AddressConst(v0) => v0.decode(buffer, stage),
            Self::LoadLocal(v0) => v0.decode(buffer, stage),
            Self::StoreLocal(v0) => v0.decode(buffer, stage),
            Self::Jump(v0) => v0.decode(buffer, stage),
            Self::IfTrue(v0) => v0.decode(buffer, stage),
            Self::IfFalse(v0) => v0.decode(buffer, stage),
            Self::DEBUG(v0) => v0.decode(buffer, stage),
            Self::LoadMutField(v0) => v0.decode(buffer, stage),
            Self::StoreMutField(v0) => v0.decode(buffer, stage),
            Self::LoadImmField(v0) => v0.decode(buffer, stage),
            Self::CreateMapEntry(v0, v1) => {
                if stage.step < v0.step_size() {
                    v0.decode(buffer, stage)
                } else {
                    v1.decode(buffer, stage)
                }
            }
            Self::MethodSelector(v0) => v0.decode(buffer, stage),
            Self::CallExternalBySelector(v0) => v0.decode(buffer, stage),
            Self::Unknown => Ok(DecodeStage::COMPLETE), // skip unknown instr
            _ => Ok(DecodeStage::COMPLETE),
        }
    }
}

#[cfg(test)]
pub mod tests {
    extern crate std;
    use crate::buffer::Buffer;
    use crate::types::u256::tests::hex_to_bytes;
    use crate::types::{Hash, LockupScript};
    use crate::{decode::*, TempData};
    use std::mem::discriminant;
    use super::Instr;

    #[test]
    fn decode_instr() {
        let mut temp_data = TempData::new();

        // TODO: use randomly generated data to improve this test
        const ALL_INSTRS: &[(u8, &str)] = &[
            (0, "0012"),
            (1, "017f"),
            (2, "02"),
            (3, "03"),
            (4, "04"),
            (5, "05"),
            (6, "06"),
            (7, "07"),
            (8, "08"),
            (9, "09"),
            (10, "0a"),
            (11, "0b"),
            (12, "0c"),
            (13, "0d"),
            (14, "0e"),
            (15, "0f"),
            (16, "10"),
            (17, "11"),
            (18, "12dc3d43c5d96c11b5ef8d581dd462b8d3ae8e11b9ab7726acc27fe28deee2a60f5a"),
            (19, "13dc9303ae010e913964a4478bad3ceea341a1d76f140085f3d4c674e1a10678d74f"),
            (20, "1400"),
            (21, "15000000000000000000000000000000000000000000000000000000000000000000"),
            (22, "1680"),
            (23, "1700"),
            (24, "18"),
            (25, "19"),
            (26, "1a"),
            (27, "1b"),
            (28, "1c"),
            (29, "1d"),
            (30, "1e"),
            (31, "1f"),
            (32, "20"),
            (33, "21"),
            (34, "22"),
            (35, "23"),
            (36, "24"),
            (37, "25"),
            (38, "26"),
            (39, "27"),
            (40, "28"),
            (41, "29"),
            (42, "2a"),
            (43, "2b"),
            (44, "2c"),
            (45, "2d"),
            (46, "2e"),
            (47, "2f"),
            (48, "30"),
            (49, "31"),
            (50, "32"),
            (51, "33"),
            (52, "34"),
            (53, "35"),
            (54, "36"),
            (55, "37"),
            (56, "38"),
            (57, "39"),
            (58, "3a"),
            (59, "3b"),
            (60, "3c"),
            (61, "3d"),
            (62, "3e"),
            (63, "3f"),
            (64, "40"),
            (65, "41"),
            (66, "42"),
            (67, "43"),
            (68, "44"),
            (69, "45"),
            (70, "46"),
            (71, "47"),
            (72, "48"),
            (73, "49"),
            (74, "4a00"),
            (75, "4b80010000"),
            (76, "4cbfff0000"),
            (77, "4d"),
            (78, "4e"),
            (79, "4f"),
            (80, "50"),
            (81, "51"),
            (82, "52"),
            (83, "53"),
            (84, "54"),
            (85, "55"),
            (86, "56"),
            (87, "57"),
            (88, "58"),
            (89, "59"),
            (90, "5a"),
            (91, "5b"),
            (92, "5c"),
            (93, "5d"),
            (94, "5e"),
            (95, "5f"),
            (96, "60"),
            (97, "61"),
            (98, "62"),
            (99, "63"),
            (100, "64"),
            (101, "65"),
            (102, "66"),
            (103, "67"),
            (104, "68"),
            (105, "69"),
            (106, "6a"),
            (107, "6b"),
            (108, "6c"),
            (109, "6d"),
            (110, "6e"),
            (111, "6f"),
            (112, "70"),
            (113, "71"),
            (114, "72"),
            (115, "73"),
            (116, "74"),
            (117, "75"),
            (118, "76"),
            (119, "77"),
            (120, "78"),
            (121, "79"),
            (122, "7a"),
            (123, "7b"),
            (124, "7c"),
            (125, "7d"),
            (126, "7e00"),
            (127, "7f"),
            (128, "80"),
            (129, "81"),
            (130, "82"),
            (131, "83"),
            (132, "84"),
            (133, "85"),
            (134, "86"),
            (135, "87"),
            (136, "88"),
            (137, "89"),
            (138, "8a"),
            (139, "8b"),
            (140, "8c"),
            (160, "a07f"),
            (161, "a180"),
            (162, "a2"),
            (163, "a3"),
            (164, "a4"),
            (165, "a5"),
            (166, "a6"),
            (167, "a7"),
            (168, "a8"),
            (169, "a9"),
            (170, "aa"),
            (171, "ab"),
            (172, "ac"),
            (173, "ad"),
            (174, "ae"),
            (175, "af"),
            (176, "b0"),
            (177, "b1"),
            (178, "b2"),
            (179, "b3"),
            (180, "b4"),
            (181, "b5"),
            (182, "b6"),
            (183, "b7"),
            (184, "b8"),
            (185, "b9"),
            (186, "ba"),
            (187, "bb"),
            (188, "bc"),
            (189, "bd"),
            (190, "be"),
            (191, "bf"),
            (192, "c0"),
            (193, "c1"),
            (194, "c2"),
            (195, "c3"),
            (196, "c4"),
            (197, "c5"),
            (198, "c6"),
            (199, "c7"),
            (200, "c8"),
            (201, "c9"),
            (202, "ca"),
            (203, "cb"),
            (204, "cc"),
            (205, "cd"),
            (206, "ce00"),
            (207, "cf"),
            (208, "d0"),
            (209, "d1"),
            (210, "d27f7f"),
            (211, "d300000000"),
            (212, "d400000000")
        ];

        for &(code, hex) in ALL_INSTRS {
            let bytes = hex_to_bytes(hex).unwrap();
            let mut decoder = new_decoder::<Instr>();
            let mut buffer = Buffer::new(&bytes, &mut temp_data);
            let decoded_instr = decoder.decode(&mut buffer).unwrap().unwrap();

            let instr = Instr::from_type(code);
            assert!(instr.is_some());
            assert_eq!(discriminant(instr.as_ref().unwrap()), discriminant(decoded_instr));
            match decoded_instr {
                Instr::CallLocal(v) => assert!(v.0 == bytes[1]),
                Instr::CallExternal(v) => assert!(v.0 == bytes[1]),
                Instr::I256Const(v) => {
                    assert!(bytes.len() == 34);
                    assert!(v.0.bytes == &bytes[1..]);
                },
                Instr::U256Const(v) => {
                    assert!(bytes.len() == 34);
                    assert!(v.0.bytes == &bytes[1..]);
                },
                Instr::BytesConst(v) => {
                    assert!(bytes.len() == 2);
                    assert!(v.length.inner == 0);
                },
                Instr::AddressConst(v) => {
                    assert!(*v == LockupScript::P2PKH(Hash::from_bytes([0u8; 32])));
                },
                Instr::LoadLocal(v) => assert!(v.0 == bytes[1]),
                Instr::StoreLocal(v) => assert!(v.0 == bytes[1]),
                Instr::Jump(v) => assert!(v.inner == 0),
                Instr::IfTrue(v) => assert!(v.inner == 65536),
                Instr::IfFalse(v) => assert!(v.inner == -65536),
                Instr::DEBUG(v) => assert!(v.is_empty()),
                Instr::LoadMutField(v) => assert!(v.0 == bytes[1]),
                Instr::StoreMutField(v) => assert!(v.0 == bytes[1]),
                Instr::LoadImmField(v) => assert!(v.0 == bytes[1]),
                Instr::CreateMapEntry(v0, v1) => assert!(v0.0 == bytes[1] && v1.0 == bytes[2]),
                Instr::MethodSelector(v) => assert!(v.0 == 0),
                Instr::CallExternalBySelector(v) => assert!(v.0 == 0),
                instr => assert!(*decoded_instr == *instr),
            }
        }
    }

    #[test]
    fn decode_unknown_instr() {
        let mut temp_data = TempData::new();
        let mut decoder = new_decoder::<Instr>();
        let mut buffer = Buffer::new(&[255], &mut temp_data);
        let instr = decoder.decode(&mut buffer).unwrap().unwrap();
        assert!(*instr == Instr::Unknown);
    }
}
